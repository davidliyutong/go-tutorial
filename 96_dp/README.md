# 设计模式

在软件开发中，经常会遇到各种各样的编码场景，这些场景往往重复发生，因此具有典型性。针对这些典型场景，可以自己编码解决，也可以采取更为省时省力的方式：直接采用设计模式。设计模式简单来说，就是将软件开发中需要重复性解决的编码场景，按最佳实践的方式抽象成一个模型，模型描述的解决方法就是设计模式。使用设计模式，可以使代码更易于理解，保证代码的重用性和可靠性。

在软件领域，GoF（四人帮，全拼 Gang of Four）首次系统化提出了 3 大类、共 25 种可复用的经典设计方案，来解决常见的软件设计问题，为可复用软件设计奠定了一定的理论基础。从总体上说，这些设计模式可以分为创建型模式、结构型模式、行为型模式 3 大类，用来完成不同的场景。

本章会介绍几个在 Go 项目开发中比较常用的设计模式，帮助用更加简单快捷的方法应对不同的编码场景。其中，简单工厂模式、抽象工厂模式和工厂方法模式都属于工厂模式。

<img src="figures/image-20221103203742194.png" alt="image-20221103203742194" style="zoom:50%;" />

## 创建型

创建型模式（Creational Patterns）提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。

### 单例模式

单例模式（Singleton Pattern）是最简单的一个模式，在 Go 中指的是全局只有一个实例，并且它负责创建自己的对象。单例模式不仅有利于减少内存开支，还有减少系统性能开销、防止多个实例产生冲突等优点。因为单例模式保证了实例的全局唯一性，而且只被初始化一次，所以比较适合全局共享一个实例，且只需要被初始化一次的场景，例如数据库实例、全局配置、全局任务池等。

单例模式又分为饿汉方式和懒汉方式：

- 饿汉方式：指全局的单例实例在包被加载时创建
- 懒汉方式：指全局的单例实例在第一次被使用时创建

- [单例模式](10_singleton/main.go)：对于“饿汉模式”，因为实例是在包被导入时初始化的，所以如果初始化耗时，会导致程序加载时间比较长。懒汉方式是开源项目中使用最多的，但它的缺点是非并发安全，在实际使用时需要加锁。使用 once.Do 可以确保 ins 实例全局只被创建一次，once.Do 函数还可以确保当同时有多个创建动作时，只有一个创建动作被执行。

```bash
cd 10_singleton
go run main.go
```

### 工厂模式

工厂模式（Factory Pattern）是面向对象编程中的常用模式。在 Go 项目开发中，可以通过使用多种不同的工厂模式，来使代码更简洁明了。Go 中的结构体+方法，可以理解为面向对象编程中的类。有了 “类”，就可以创建“类”相关的实例。可以通过简单工厂模式、抽象工厂模式、工厂方法模式这 3 种方式，来创建实例。

#### 简单工厂模式

简单工厂模式是最常用、最简单的。它就是一个接受一些参数，然后返回实例的函数。参考代码案例，和 `p：=＆Person {}` 这种创建实例的方式相比，简单工厂模式可以确保创建的实例具有需要的参数，进而保证实例的方法可以按预期执行。例如，通过 NewPerson() 创建 Person 实例时，可以确保实例的 name 和 age 属性被设置。

- [简单工厂模式](20_factory/10_simple.go)

```bash
cd 20_factory
go run 10_simple.go
```

#### 抽象工厂模式

抽象工厂模式与简单工厂模式的唯一区别，就是它返回的是接口而不是结构体。通过返回接口，可以在不公开内部实现的情况下，让调用者使用提供的各种功能。

##### Lab

- [抽象工厂模式](20_factory/20_abstract.go)

```bash
go run 20_factory/20_abstract.go
```

#### 工厂方法模式

在简单工厂模式中，依赖于唯一的工厂对象，如果需要实例化一个产品，就要向工厂中传入一个参数，获取对应的对象。但如果要增加一种产品，就要在工厂中修改创建产品的函数。这会导致耦合性过高，这时就可以使用工厂方法模式。

在工厂方法模式中，将返回工厂函数，可以通过实现工厂函数来创建多种工厂，从而将过程解耦。

##### Lab
- [工厂方法模式](20_factory/30_method.go)

```bash
go run 20_factory/30_method.go
```

### 创造者模式



### 原型模式



## 结构型

行为型模式（Behavioral Pattern），它的特点是关注类和对象的组合。

### 策略模式

策略模式（Strategy Pattern）定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。根据不同的场景，采取不同的措施，也就是不同的策略。假设需要对 a、b 这两个整数进行计算，根据条件的不同，需要执行不同的计算方式。可以把所有的操作都封装在同一个函数中，然后通过 if ... else ... 的形式来调用不同的计算方式，这种方式称之为硬编码。

在实际应用中，随着功能和体验的不断增长，需要经常添加/修改策略，这样就需要不断修改已有代码，不仅会让这个函数越来越难维护，还可能因为修改带来一些 bug。所以为了解耦，需要使用策略模式，定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法（即策略）。

#### Lab

- [Operator 配置 Strategy](30_strategy/10_strategy/main.go)

### 模板模式

模版模式（Template Pattern）定义一个操作中算法的骨架，而将一些步骤延迟到子类中。这种方法让子类在不改变一个算法结构的情况下，就能重新定义该算法的某些特定步骤。

简单来说，模板模式就是将一个类中能够公共使用的方法放置在抽象类中实现，将不能公共使用的方法作为抽象方法，强制子类去实现，这样就做到了将一个类作为一个模板，让开发者去填充需要填充的地方。

- [模板模式](35_template/main.go)

```bash
go run 35_template/main.go
```



### 访问者模式



### 状态模式



### 备忘录模式

备忘录模式允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。备忘录不会影响它所处理的对象的内部结构，也不会影响快照中保存的数据。一般情况由原发对象保存生成的备忘录对象的状态不能被除原发对象之外的对象访问，所以通过内部类定义具体的备忘录对象是比较安全的。但 Go 不支持内部类定义的方式，因此 Go 实现备忘录对象时，首先将备忘录保存的状态设为非导出字段，避免外部对象访问，其次将原发对象的引用保存到备忘录对象中，当通过备忘录对象恢复时，直接操作备忘录的恢复方法，将备份数据状态设置到原发对象中，完成恢复。

示例

大家平时玩的角色扮演闯关游戏的存档机制就可以通过备忘录模式实现，每到一个关键关卡，玩家经常会先保存游戏存档，用于闯关失败后重置，存档会把角色状态及场景状态保存到备忘录中，同时将需要恢复游戏的引用存入备忘录，用于关卡重置；

### 观察者模式

观察者模式允许自定义一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象。观察者模式提供了一种作用于任何实现了订阅者接口的对象的机制，可对其事件进行订阅和取消订阅。观察者模式是最常用的模式之一是事件总线，分布式消息中间件等各种事件机制的原始理论基础，常用于解耦多对一的对象依赖关系。其增强的实现功能包括：

1. 当被观察者通过异步实现通知多个观察者时就相当于单进程实例的消息总线；
2. 同时还可以根据业务需要，将被观察者所有数据状态变更进行分类为不同的主题，观察者通过不同主题进行订阅；
3. 同一个主题又可分为增加、删除、修改事件行为；
4. 每个主题可以实现一个线程池，多个主题通过不同的线程池进行处理隔离，线程池可以设置并发线程大小、缓冲区大小及调度策略，比如先进先出，优先级等策略；
5. 观察者处理事件时有可能出现异常，所以也可以注册异常处理函数，异常处理也可以通过异常类型进行分类；
6. 根据业务需求也可以实现通知异常重试，延迟通知等功能；

[本示例]()描述信用卡业务消息提醒可通过观察者模式实现，业务消息包括日常消费、出账单、账单逾期，消息提醒包括短信、邮件及电话。根据不同业务的场景会采用不同的消息提醒方式或多种消息提醒方式，这里信用卡相当于被观察者，观察者相当于不同的通知方式。日常消费通过短信通知，出账单通过邮件通知，账单逾期三种方式都会进行通知。

### 中介者模式

中介者模式用来减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作，将网状依赖变为星状依赖。中介者能使得程序更易于修改和扩展，而且能更方便地对独立的组件进行复用，因为它们不再依赖于很多其他的类。

中介者模式与观察者模式之间的区别是，中介者模式解决的是同类或不同类的多个对象之间多对多的依赖关系，观察者模式解决的是多个对象与一个对象之间的多对一的依赖关系。

[本示例](75_mediator/main.go)描述机场塔台调度系统，假设是一个小机场，每次只能同时允许一架飞机起降，每架靠近机场的飞机需要先与塔台沟通是否可以降落。如果没有空闲的跑道，需要在天空盘旋等待。如果有飞机离港，等待的飞机会收到塔台的通知，按先后顺序降落。这种方式免去多架飞机同时到达机场需要相互沟通降落顺序的复杂性，减少多个飞机间的依赖关系、简化业务逻辑，从而降低系统出问题的风险。



### 迭代器模式

迭代器模式能在不暴露集合底层表现形式 （列表、 栈和树等）的情况下遍历集合中所有的元素。在迭代器的帮助下， 客户端可以用一个迭代器接口以相似的方式遍历不同集合中的元素。这里需要注意的是有两个典型的迭代器接口需要分清楚:一个是集合类实现的可以创建迭代器的工厂方法接口一般命名为 Iterable，包含的方法类似 CreateIterator；另一个是迭代器本身的接口，命名为 Iterator，有 Next 及 hasMore 两个主要方法.

#### 示例

[本示例](76_iterator/main.go)描述一个班级类中包括一个老师和若干个学生，要对班级所有成员进行遍历，班级中老师存储在单独的结构字段中，学生存储在另外一个 slice 字段中，通过迭代器可以实现统一遍历处理。

### 解释器模式



### 命令模式

命令模式将请求转换为一个包含与请求相关的所有信息的独立对象。该转换能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。方法参数化是指将每个请求参数传入具体命令的工厂方法创建命令，同时具体命令会默认设置好接受对象，这样做的好处是不管请求参数个数及类型，还是接受对象有几个，都会被封装到具体命令对象的成员字段上，并通过统一的 Execute 接口方法进行调用，屏蔽各个请求的差异，便于命令扩展，多命令组装，回滚等。

#### 示例

[本示例]()控制电饭煲做饭是一个典型的命令模式的场景，电饭煲的控制面板会提供设置煮粥、蒸饭模式，及开始和停止按钮，电饭煲控制系统会根据模式的不同设置相应的火力，压强及时间等参数。煮粥、蒸饭就相当于不同的命令，开始按钮就相当命令触发器，设置好做饭模式，点击开始按钮电饭煲就开始运行，同时还支持停止命令。

### 责任链模式

责任链模式允许将请求沿着“处理者”链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。该模式允许多个对象来对请求进行处理，而无需让发送者类与具体接收者类相耦合。链可在运行时由遵循标准处理者接口的任意处理者动态生成。

一般意义上的责任链模式是说，请求在链上流转时任何一个满足条件的节点处理完请求后就会停止流转并返回，不过还可以根据不同的业务情况做一些改进：

1. 请求可以流经处理链的所有节点，不同节点会对请求做不同职责的处理；
2. 可以通过上下文参数保存请求对象及上游节点的处理结果，供下游节点依赖，并进一步处理；
3. 处理链可支持节点的异步处理，通过实现特定接口判断，是否需要异步处理；
4. 责任链对于请求处理节点可以设置停止标志位，不是异常，是一种满足业务流转的中断；
5. 责任链的拼接方式存在两种，一种是节点遍历，一个节点一个节点顺序执行；另一种是节点嵌套，内层节点嵌入在外层节点执行逻辑中，类似递归，或者“回”行结构；
6. 责任链的节点嵌套拼接方式多被称为拦截器链或者过滤器链，更易于实现业务流程的切面，比如监控业务执行时长，日志输出，权限校验等；

#### 示例

[本示例](80_chain/main.go)模拟实现机场登机过程，第一步办理登机牌，第二步如果有行李、办理托运，第三步核实身份，第四步安全检查，第五步完成登机。其中行李托运是可选的，其他步骤必选，必选步骤有任何不满足就终止登机。旅客对象作为请求参数上下文，每个步骤会根据旅客对象状态判断是否处理或流转下一个节点。

```bash
go run
```







## 行为型

结构型模式（Structural Pattern），它的特点是关注对象之间的通信。

### 代理模式

代理模式 (Proxy Pattern)，可以为另一个对象提供一个替身，以控制对这个对象的访问。

Proxy 将对象嵌入其结构体，从而可通过 Proxy 的方法操作对象。

- [代理模式](60_proxy/main.go)

```bash
go run 60_proxy/main.go
```

### 选项模式

Go 中的参数传递有多种方式。

#### 普通传参

Go 语言支持按顺序传入参数来调用函数，下面是一个示例函数：

```go
// ListApplications 查询应用列表
func ListApplications(limit, offset int) []Application {
	return allApps[offset : offset+limit]
}
```

调用代码：

```go
ListApplications(5, 0)
```

当想要增加新参数时，可以直接修改函数签名。比如，下面的代码给 `ListApplications` 增加了新的过滤参数 `owner`：

```go
func ListApplications(limit, offset int, owner string) []Application {
	if owner != "" {
		// ...
	}
	return allApps[offset : offset+limit]
}
```

调用代码也需要随之改变：

```go
ListApplications(5, 0, "wukong")
// 不使用 owner 过滤
ListApplications(5, 0, "")
```

显而易见，这种普通传参模式存在以下几个明显的缺点：

- 可读性不佳：只支持用位置，不支持用关键字来区分参数，参数变多后，各参数含义很难一目了然。
- 破坏兼容性：增加新参数后，原有调用代码必须进行对应修改，比如像上方的 `ListApplications(5, 0, "")` 一样，在 `owner` 参数的位置传递空字符串。

为了解决这些问题，常见的做法是引入一个参数结构体（struct）传参。

#### 可变传参

除了普通传参模式外，Go 还支持可变数量的参数，使用该特性的函数统称为“可变参数函数（varadic functions）”。比如 `append`、`fmt.Println` 均属此类。

```go
nums := []int{}
// 调用 append 时，传多少个参数都行 
nums = append(nums, 1, 2, 3, 4)
```

#### 结构体传参

新建一个结构体类型，里面包含函数需要支持的所有参数：

```go
// ListAppsOptions 是查询应用列表时的可选项
type ListAppsOptions struct {
	limit  int
	offset int
	owner  string
}
```

修改原函数，直接接收该结构体类型作为唯一参数：

```go
// ListApplications 查询应用列表，使用基于结构体的查询选项
func ListApplications(opts ListAppsOptions) []Application {
	if opts.owner != "" {
		// ...
	}
	return allApps[opts.offset : opts.offset+opts.limit]
}
```

调用代码如下所示：

```go
ListApplications(ListAppsOptions{limit: 5, offset: 0, owner: "wukong"})
ListApplications(ListAppsOptions{limit: 5, offset: 0})
```

相比普通模式，使用结构体传参有以下几个优势：

- 构建参数结构体时，可显式指定各参数的字段名，可读性佳。
- 对于非必选参数，构建时可不传值，比如上面省略了 `owner`。

##### 可选参数

不过，无论是使用普通传参还是结构体传参，都无法支持真正的可选参数。给 `ListApplications`  函数增加一个新选项：`hasDeployed`——根据应用是否已部署来过滤结果。

参数结构体调整如下：

```go
// ListAppsOptions 是查询应用列表时的可选项
type ListAppsOptions struct {
	limit       int
	offset      int
	owner       string
	hasDeployed bool
}
```

查询函数也做出对应调整：

```go
// ListApplications 查询应用列表，增加对 HasDeployed 过滤
func ListApplications(opts ListAppsOptions) []Application {
	// ...
	if opts.hasDeployed {
		// ...
	} else {
		// ...
	}
	return allApps[opts.offset : opts.offset+opts.limit]
}
```

想过滤已部署的应用时，可以调用：

```go
ListApplications(ListAppsOptions{limit: 5, offset: 0, hasDeployed: true})
```

而当不需要按“部署状态”过滤时，可以删除 `hasDeployed` 字段，用以下代码调用 `ListApplications` 函数：

```go
ListApplications(ListAppsOptions{limit: 5, offset: 0})
```

但问题在于 `hasDeployed` 是布尔类型，这意味着当不为其提供任何值时，程序总是会使用布尔类型的零值（zero value）：`false`。

所以，现在的代码其实根本拿不到“未按已部署状态过滤”的结果，`hasDeployed` 要么为 `true`，要么为 `false`，不存在其他状态。

##### 指针类型支持可选

为了解决上面的问题，最直接的做法是引入指针。和普通的值类型不同，Go 里的指针类型拥有一个特殊的零值：`nil`。因此，只要把 `hasDeployed`  从布尔类型（`bool`）改成指针类型（`*bool`），就能更好地支持可选参数：

```go
// ListAppsOptions 是查询应用列表时的可选项
type ListAppsOptions struct {
	limit  int
	offset int
	owner  string
	// 启用指针类型
	hasDeployed *bool
}
```

查询函数也需要做一些调整：

```go
// ListApplications 查询应用列表，增加对 HasDeployed 过滤
func ListApplications(opts ListAppsOptions) []Application {
	// ...
	if opts.hasDeployed == nil {
		// 默认不过滤分支
	} else {
		// 按 hasDeployed 为 true 或 false 来过滤
	}
	return allApps[opts.offset : opts.offset+opts.limit]
}
```

在调用函数时，调用方如不指定 `hasDeployed` 字段的值，代码就会进入 `if opts.hasDeployed == nil` 分支，不做任何过滤：

```go
ListApplications(ListAppsOptions{limit: 5, offset: 0})
```

当调用方想按 `hasDeployed` 过滤时，可以采用下面的方式：

```go
wantHasDeployed := true
ListApplications(ListAppsOptions{limit: 5, offset: 0, hasDeployed: &wantHasDeployed})
```

如所见，因为 `hasDeployed` 如今是指针类型 `*bool` ，所以必须得先创建一个临时变量，然后取它的指针去调用函数。不得不说，这挺麻烦的对不？有没有一种方式，既能解决前面这些函数传参时的痛点，又能让调用过程不要像“手动造指针”这么麻烦呢？接下来便该选项模式出场了。

#### 函数选项模式

选项模式（Options Pattern）是 Go 中经常使用到的模式，它以“参数设置函数”来代替结构体传递给函数。如 grpc/grpc-go 的 NewServer 函数，uber-go/zap 的 New 函数都用到了选项模式。使用选项模式，可以创建一个带有默认值的 struct 变量，并选择性地修改其中一些参数的值。

为了实现“函数式选项”模式，首先修改 `optionFunc` 函数的签名，使其接收类型为 `func(*options)` 的可变数量参数。

```go
type optionFunc func(*options)

func (f optionFunc) apply(o *options) {
    f(o)
}
```

然后，再定义一系列用于设置选项的参数设置函数，这些以 `With*` 命名，通过返回闭包函数来修改函数选项对象 `Option`。

```go
func WithTimeout(t time.Duration) Option {
    return optionFunc(func(o *options) {
        o.timeout = t
    })
}

func WithCaching(cache bool) Option {
    return optionFunc(func(o *options) {
        o.caching = cache
    })
}
```

调用时的代码如下：

```go
// 不使用任何参数
NewConnect()
// 选择性启用某些选项
NewConnect(WithTimeout(8))
NewConnect(WithTimeout(8), WithCachine(true))
```

Option 类型的选项参数需要实现 apply(*options) 函数，结合 WithTimeout、WithCaching 函数的返回值和 optionFunc 的 apply 方法实现，可以知道 o.apply(&options) 其实就是把 WithTimeout、WithCaching 传入的参数赋值给 options 结构体变量，以此动态地设置 options 结构体变量的属性。和使用“结构体传参”相比，“选项模式”有以下几个特点：

- 更友好的可选参数：比如不再需要手动为 `hasDeployed` 取指针。
- 灵活性更强：可以方便地在每个 `With*` 函数里追加额外逻辑。
- 向前兼容性好：任意增加新的选项都不会影响已有代码。
- 更漂亮的 API：当参数结构体很复杂时，该模式所提供的 API 更漂亮，也更好用。



### 适配器模式



### 桥接模式



### 组合模式



### 装饰模式



### 外观模式



### 享元模式



## 额外

### SchemeBuilder

- [SchemeBuilder](88_scheme-builder/README.md)

