# 日志

通过记录日志可以完成一些基本功能，如开发、测试期间的 Debug、故障排除、数据分析、监控告警，以及记录发生的事件等。要实现这些功能，需要 2 部分：

- 首先，需要一个优秀的日志包。
- 另外，还需要一个日志记录规范，知道怎么更好地记录日志。

有了优秀的日志包和日志记录规范，就能很快地定位到问题，获取足够的信息，并完成后期的数据分析和监控告警，也可以很方便地进行调试了。

## 日志包

### 基本信息

支持基本的日志信息日志包需要支持基本的日志信息，包括时间戳、文件名、行号、日志级别和日志信息。

- 时间戳：可以记录日志发生的时间。在定位问题时，需要根据时间戳来复原请求过程，核对相同时间戳下的上下文，从而定位出问题。
- 文件名和行号：可以更快速定位到打印日志的位置，找到问题代码。一个日志库如果不支持文件名和行号，排查故障就会变得非常困难，基本只能靠 grep 来定位代码。通过文件名和行号，可以精准定位到问题代码，尽快地修复问题并恢复服务。
- 日志级别：通过日志级别可以知道日志的错误类型，最通常的用法是：直接过滤出 Error 级别的日志，这样就可以直接定位出问题出错点，然后再结合其他日志定位出出错的原因。如果不支持日志级别，在定位问题时，可能要查看一大堆无用的日志。
- 支持自定义配置：不同的运行环境，需要不同的日志输出配置。例如：开发测试环境为了能够方便地 Debug，需要设置日志级别为 Debug 级别。现网环境为了提高应用程序的性能，则需要设置日志级别为 Info 级别。又如，现网环境为了方便日志采集，通常会输出 JSON 格式的日志；开发测试环境为了方便查看日志，会输出 TEXT 格式的日志。所以，日志包需要能够被配置，还要不同环境采用不同的配置。
- 支持输出到标准输出和文件：日志总是要被读的，要么输出到标准输出，供开发者实时读取，要么保存到文件，供开发者日后查看。输出到标准输出和保存到文件是一个日志包最基本的功能。在分布式系统中，一个服务会被部署在多台机器上，这时候如果要查看日志，就需要分别登录不同的机器查看，非常麻烦。所以需要将日志统一投递到 Elasticsearch、Kafka 等组件上。

### 日志级别

不同的日志级别代表不同的日志类型

- Error 级：说明日志是错误类型，在排障时会首先查看错误级别的日志。
- Warn 级：说明出现异常，但还不至于影响程序运行，如果程序执行的结果不符合预期，则可以参考 Warn 级别的日志，定位出异常所在。
- Info 级：可以协助 Debug，并记录一些有用的信息，供后期进行分析。通常一个日志包至少要实现 6 个级别：

<img src="figures/bb1356bd3cf332ddeb30d3aef8fc8d2b.png" alt="img" style="zoom:50%;" />

打印日志时，一个日志调用其实具有两个属性：

- 输出级别：打印日志时，期望日志的输出级别。如调用 glog.Info("This is info message") 打印一条日志，则输出日志级别为 Info。
- 开关级别：启动应用程序时，期望哪些输出级别的日志被打印。如使用 glog 时 -v=4 ，说明了只有日志级别高于 4 的日志才会被打印。如果开关级别设置为 L ，只有输出级别 >=L 的日志才会被打印。如开关级别为 Warn，则只会记录 Warn、Error 、Panic 和 Fatal 级别的日志。

## 日志使用规范

### 打印位置

日志主要是用来定位问题的，所以要在有需要的地方打印日志：

- 在分支语句处打印日志：在分支语句处打印日志，可以判断出代码走了哪个分支，有助于判断请求的下一跳，继而继续排查问题。
- 写操作必须打印日志：写操作最可能会引起比较严重的业务故障，写操作打印日志，可以在出问题时找到关键信息。
- 在循环中打印日志要慎重：如果循环次数过多，会导致打印大量的日志，严重拖累代码的性能，建议的办法是在循环中记录要点，在循环外面总结打印出来。
- 在错误产生的最原始位置打印日志：对于嵌套的 Error，可在 Error 产生的最初位置打印 Error 日志。上层如果不需要添加必要的信息，可以直接返回下层的 Error。通过在最初产生错误的位置打印日志，可以很方便地追踪到日志的根源，进而在上层追加一些必要的信息。这可以了解到该错误产生的影响，有助于排障。另外，直接返回下层日志，还可以减少重复的日志打印。

### 打印级别

不同级别的日志，具有不同的意义，能实现不同的功能。在开发中，需要根据目的在合适的级别记录日志。

- Debug 级：别为了获取足够的信息进行 Debug，通常会在 Debug 级别打印很多日志。例如，可以打印整个 HTTP 请求或响应的 Body。Debug 级别需要打印大量的日志，这会严重拖累程序的性能。并且，Debug 级别的日志，主要是为了能在开发测试阶段更好地 Debug，多是一些不影响现网业务的日志信息。所以，对于 Debug 级别的日志，在服务上线时一定要禁止掉。否则，就可能会因为大量的日志导致硬盘空间快速用完，从而造成服务宕机。Debug 这个级别的日志可以随意输出，任何得有助于开发、测试阶段调试的日志，都可以在这个级别打印。
- Info 级：Info 级的日志可以记录一些有用的信息，供以后的运营分析，所以 Info 级的日志不是越多越好，也不是越少越好，应以满足需求为主要目标。一些关键日志，可以在 Info 级记录，但如果日志量大、输出频度过高，则要考虑在 Debug 级别记录。现网的日志级别一般是 Info 级，为了不使日志文件占满整个磁盘空间，在记录日志时，要注意避免产生过多的 Info 级的日志。例如，在 for 循环中，就要慎用 Info 级别的日志。
- Warn 级：一些警告类的日志可以记录在 Warn 级，Warn 级的日志往往说明程序运行异常、不符合预期，但又不影响程序的继续运行，或是暂时影响，但后续会恢复。Warn 更多的是业务级别的警告日志。
- Error 级：Error 级的日志描述程序执行出错，这些错误肯定会影响到程序的执行结果，例如请求失败、创建资源失败等。要记录每一个发生错误的日志，避免日后排障过程中这些错误被忽略掉。大部分的错误可以归在 Error 级别。
- Panic 级：Panic 级的日志在实际开发中很少用，通常只在需要错误堆栈，或不想因为发生严重错误导致程序退出，而采用 defer 处理错误时使用。
- Fatal 级：Fatal 是最高级别的日志，这个级别的日志说明问题已经相当严重，严重到程序无法继续运行，通常是系统级的错误。在开发中也很少使用，除非觉得某个错误发生时，整个程序无法继续运行。

<img src="figures/75e8c71a791f279a68c35734f2451035-20220331144834670.png" alt="img" style="zoom:50%;" />

### 日志内容

关于如何记录日志内容，有几条建议：

- 在记录日志时，不要输出一些敏感信息，例如密码、密钥等。
- 为了方便调试，通常会在 Debug 级别记录一些临时日志，这些日志内容可以用一些特殊的字符开头，例如 log.Debugf("XXXXXXXXXXXX-1:Input key was: %s", setKeyName) 。这样，在完成调试后，可以通过查找 XXXXXXXXXXXX 字符串，找到这些临时日志，在 commit 前删除。
- 日志内容应该小写字母开头，以英文点号 . 结尾，例如 log.Info("update user function called.") 。
- 为了提高性能，尽可能使用明确的类型，如使用 log.Warnf("init datastore: %s",  err.Error()) 而非 log.Warnf("init datastore: %v", err)  。
- 日志最好包含两个信息：一个是请求 ID（每次请求的唯一 ID），便于从海量日志中过滤出某次请求的日志，可以将请求 ID 放在请求的通用日志字段中。另一个是用户和行为，用于标识谁做了什么。
- 不要将日志记录在错误的日志级别上：例如，经常会发现有人将正常的日志信息打印在 Error 级，将错误的日志信息打印在 Info 级。

### 最佳实践

- 开发调试、现网故障排障时，不要遗忘一件事情：根据排障的过程优化日志打印。好的日志，可能不是一次就可以写好的，可以在实际开发测试，还有现网定位问题时不断优化。
- 打印日志要“不多不少”：避免打印没用的日志，也不要遗漏关键的日志信息。最好的信息是，仅凭借这些关键的日志就能定位到问题。
- 支持动态日志输出，方便线上问题定位。
- 总将日志记录在本地文件：通过将日志记录在本地文件，可以和日志中心化平台进行解耦，这样当网络不可用或日志中心平台故障时，仍然能够正常的记录日志。
- 集中化日志存储处理：因为应用可能包含多个服务，一个服务包含多个实例，为了查看日志方便，最好将这些日志统一存储在同一个日志平台上，如 Elasticsearch，方便集中管理和查看日志。
- 结构化日志记录：添加一些默认通用的字段到每行日志，方便日志查询和分析。
- 支持 RequestID：使用 RequestID 串联一次请求的所有日志，这些日志可能分布在不同的组件，不同的机器上。支持 RequestID 可以大大提高排障的效率，降低排障难度。在一些大型分布式系统中，没有 RequestID 排障简直就是灾难。
- 支持动态开关 Debug 日志：对于定位一些隐藏得比较深的问题，可能需要更多的信息，这时候可能需要打印 Debug 日志。但现网的日志级别会设置为 Info 级别，为了获取 Debug 日志，可能会修改日志级别为 Debug 级别并重启服务，定位完问题后，再修改日志级别为 Info 级别，然后再重启服务，这种方式不仅麻烦而且还可能会对现网业务造成影响。最好的办法是能够在请求中通过 debug=true 这类参数动态控制某次请求是否开启 Debug 日志。

## Lab

### 标准log包

Go 标准的 pkg/log 包

- [log print](10_log/10_print.go)
- [log fatal](10_log/20_fatal.go)
- [log panic](10_log/30_panic.go)
- [log customize](10_log/40_customize.go)

```bash
go run 10_log/10_print.go
```

```bash
go run 10_log/20_fatal.go
echo $?
```

```bash
go run 10_log/30_panic.go
```

```bash
go run 10_log/40_customize.go
```

### wklog

wklog 是一个简单的 log 包实现，demo 中主要展示了 WithLevel() 和 WithFormatter() 两个函数的设置。

- [example.go](20_wklog/example.go)

```bash
go run 20_wklog/example.go
```

### pkg/log

是个可在生产环境使用的 log 包，需要设置的配置参数为：

- `writers`：输出位置，有两个可选项 —— file 和 stdout。选择 file 会将日志记录到 `logger_file` 指定的日志文件中，选择 stdout 会将日志输出到标准输出，当然也可以两者同时选择
- `logger_level`：日志级别，DEBUG、INFO、WARN、ERROR、FATAL
- `logger_file`：日志文件
- `log_format_text`：日志的输出格式，JSON 或者 plaintext，`true` 会输出成非 JSON 格式，`false` 会输出成 JSON 格式
- `rollingPolicy`：rotate 依据，可选的有 daily 和 size。如果选 daily 则根据天进行转存，如果是 size 则根据大小进行转存
- `log_rotate_date`：rotate 转存时间，配 合`rollingPolicy: daily` 使用
- `log_rotate_size`：rotate 转存大小，配合 `rollingPolicy: size` 使用
- `log_backup_count`：当日志文件达到转存标准时，log 系统会将该日志文件进行压缩备份，这里指定了备份文件的最大个数

- [example1.go](30_rebirthmonkey-log/example1.go)
- [example2.go](30_rebirthmonkey-log/example2.go)

```bash
cd 30_rebirthmonkey-log
go run example1.go
go run example2.go
go run example2.go -l warn
```

## apiserver 示例

在原先的实例中，所有的输出都是通过 `fmt.Print()` 的方式，这样在实际生产环境中无法持久化。在生产环境中推荐使用 log 的形式输出，方便后续联调排错，详细介绍[在此](80_server/README.md)。
